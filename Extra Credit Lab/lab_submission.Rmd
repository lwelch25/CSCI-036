---
title: 'Lab:  Extra Credit on Midterm 1'
author: "Mark Huber"
output: 
  html_document:
    css:  ../lab-style.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.height = 3, fig.width = 5)
options(tibble.width = 62)
```

## Packages

The packages needed for the lab today are:

* [dplyr]{class=PackageName} for [summarize]{class=KeywordTok} and [group_by]{class=PackageName}.

* [tibble]{class=PackageName} for creating tibbles.

* [knitr]{class=PackageName} for creating tables from tibbles.

```{r, warning = FALSE, message = FALSE}
library(dplyr)
library(tibble)
library(knitr)
```

# [summarize]{class=KeywordTok}

There are several commands built into R called *vector operations* that take a vector of data, and perform some sort of calculation on them.  For instance, [mean]{class=KeywordTok} takes the sample average, which is the sum of all the entries divided by the number of entries.

```{r}
mean(c(5, 3, 5))
```

How can these functions be applied to columns of data stored in a tibble.  This is accomplished through the [summarize]{class=KeywordTok} function.

This function takes as input a tibble, and as output another tibble.  It is part of the [dplyr]{class=PackageName} package.

Suppose that we have the following tibble.

```{r}
ec1 <- tibble(
  color = c("blue", "red", "red"),
  reflect = c(5, 3, 5),
  lighting = c(5, 12, 11)
)
```

Suppose that the goal is to find the mean of the `reflect` variable within `ec1`.  Then pipe the data into [summarize]{class=Keyword}, and the inputs to [summarize]{class=Keyword} are of the form *variable to create* = *function to use on the data*.

To find the mean of the reflect variable:
```{r}
ec1 |>
  summarize(mean_reflect = mean(reflect))
```
If there was just *function to apply to the data* and no equals sign in the input to [summarize]{class=KeywordTok}, then the column is just named the same thing as the function call.

```{r}
ec1 |>
  summarize(mean(reflect))
```
It's best to rename things, though, since that way there are no parentheses or other special characters in the column names.

You can put as many inputs to [summarize]{class=KeywordTok} as you need.  Each input results in a column to the output.

For instance, this code gives three inputs to summarize:
```{r}
ec1 |>
  summarize(mean_reflect = mean(reflect),
            median_reflect = median(reflect),
            median_cross = median(lighting))
```
The following two statements are a good way of testing your understanding of what [summarize]{class=KeywordTok} does, and also gives a way of checking your answers when you build code yourself.

* The *number of rows* in the output of a basic [summarize]{class=KeywordTok} command is 1.

* The *number of columns* is the number of inputs (not counting the dataset being input) to [summarize]{class=KeywordTok}.

In the example above, there were three inputs to summarize (other than the data itself) so the output had three columns and one row.

:::: {.problem data-latex=""}
Consider the following code.

```
trattorias |>
  summarize(m = mean(price), n = n())
```


How many rows will the tibble generated by this code have?  Assign your answer to `answer01`.



::::


:::: {.solution}


```{r}
answer01 <- 1
```

::::

:::: {.problem data-latex=""}
Consider the following code.
```
trattorias |>
  summarize(m = mean(price), n = n())
```

How many columns will the tibble generated by this code have?  Assign your answer to `answer02`.
::::

```{r}
answer02 <- 2 
```

:::: {.solution}

::::

# [group_by]{class=KeywordTok}

With the [group_by]{class=KeywordTok} command, the data is split into multiple tables, each of which can be used with the summarize command.  For instance, recall the `ec1` data from before.

```{r}
ec1 |> kable()
```

If `group_by(color)` is used, since there are two levels for the `color` variable, `"blue"` and `"red"`, the table is effectively split into two tables.

```{r, echo = FALSE}
ec1 |> filter(color == "blue") |> kable()
```

```{r, echo = FALSE}
ec1 |> filter(color == "red") |> kable()
```

Of course, this is all done internally, nothing actually shows up when the [group_by]{class=KeywordTok} is used.

```{r}
ec1 |>
  group_by(color) |>
  kable()
```

But, if a [summarize]{class=KeywordTok} is used after the [group_by]{class=KeywordTok}, then each of the two tables is summarized independently, and then put back together via a union.

For example, the summary of the blue observations is 
```{r}
ec1 |>
  filter(color == "blue") |>
  summarize(mean_reflect = mean(reflect),
            median_reflect = median(reflect),
            median_cross = median(lighting))
```
To tell that these are the blue observations, an extra column could be added.

```{r}
ec1 |>
  filter(color == "blue") |>
  summarize(mean_reflect = mean(reflect),
            median_reflect = median(reflect),
            median_cross = median(lighting)) |>
  mutate("color" = "blue", .before = 1)
```

A similar thing can then be done for the two `"red"` observations.

```{r}
ec1 |>
  filter(color == "red") |>
  summarize(mean_reflect = mean(reflect),
            median_reflect = median(reflect),
            median_cross = median(lighting)) |>
  mutate("color" = "red", .before = 1)
```
Finally, the two tibbles output by [summarize]{class=KeywordTok} could be combined back together.

```{r}
union(
  ec1 |>
    filter(color == "blue") |>
    summarize(mean_reflect = mean(reflect),
              median_reflect = median(reflect),
              median_cross = median(lighting)) |>
    mutate("color" = "blue", .before = 1),
  ec1 |>
    filter(color == "red") |>
    summarize(mean_reflect = mean(reflect),
              median_reflect = median(reflect),
              median_cross = median(lighting)) |>
    mutate("color" = "red", .before = 1)
) |> kable()
```

Whew, that was a lot of work!  Fortunately, if you just `group_by(color)` before doing the summarize, then R does all this work for you!

```{r}
ec1 |>
  group_by(color) |>
  summarize(mean_reflect = mean(reflect),
            median_reflect = median(reflect),
            median_cross = median(lighting)) |> 
  kable()
```

Note that because `color` has two values it takes on, the output of the [summarize]{class=KeywordTok} will have two rows.  The number of columns is the three from the inputs to summarize, plus an extra column to label the color, the input in `group_by(color)`.

* The number of rows in the output of [summarize]{class=KeywordTok} with [group_by]{class=KeywordTok} is equal to the number of possible choices for the variables being grouped.

* The number of columns in the output of [summarize]{class=KeywordTok} is the number of inputs to [group_by]{class=KeywordTok} (ignoring the data input) plus the number of inputs to [summarize]{class=KeywordTok} (ignoring the data input).

In the example above, the `group_by(color)` had one non-data input:  `color`.  This input took on one of two values, `"blue"` or `"red"`.  The command for summarize had three inputs.  Therefore, there were two rows (for `"blue"` and `"red"`) and \( 1 + 3 = 4 \) columns (1 from the `group_by(color)` and three from the summarize command).

:::: {.problem data-latex=""}
Consider the following code.
```
trattorias |>
  group_by(district) |>
  summarize(m = mean(price), n = n())
```

The `district` variable in the `trattorias` dataset takes on twelve different values.  How many rows will the tibble generated by this code have?  Assign your answer to `answer03`.
::::

```{r}
answer03 <- 12
```


:::: {.solution}

::::

:::: {.problem data-latex=""}
Consider the following code.
```
trattorias |>
  group_by(district) |>
  summarize(m = mean(price), n = n())
```

The `district` variable in the `trattorias` dataset takes on twelve different values.  How many columns will the tibble generated by this code have?  Assign your answer to `answer04`.
::::

```{r}
answer04 <- 3
```

:::: {.solution}

::::

# Testing your knowledge

:::: {.problem data-latex=""}
Consider the `iris` dataset built into R.  Use this together with [group_by]{class=KeywordTok} and [summarize]{class=KeywordTok} to create a tibble with columns `Species`, `a`, and `b` and three rows that gives for each of the three species represented in the dataset the average `Sepal.Length` and median `Petal.Length`.  Assign your answer to `answer05`.
::::


```{r}
answer05 <- iris |>
  group_by(Species) |>
  summarize(a = mean(Sepal.Length),
            b = mean(Petal.Length))
```

:::: {.solution}

::::